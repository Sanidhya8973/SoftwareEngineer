package _03__Java_8.Java_Stream_API;

import java.util.List;
import java.util.Arrays;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.stream.Stream;

public class Main {

    public static void main(String[] args) {

        Character[] cArr = {'a', 'b', 'c', 'd'};
        List<Character> cList = Arrays.asList('A', 'B', 'C', 'D');

        Consumer<Stream<?>> println = (stream) -> stream.forEach(System.out::println);

        // Arrays.stream(T[] array); // creates a stream from an array
        Stream<Character> stream1 = Arrays.stream(cArr);
        println.accept(stream1);

        // Arrays.stream(T[] array, int startInclusive, int endExclusive); // creates a stream from a part of an array
        Stream<Character> stream2 = Arrays.stream(cArr, 1, 3); // [1,2]
        println.accept(stream2);

        // Collection.stream(); // returns a sequential stream
        Stream<Character> stream3 = cList.stream();
        println.accept(stream3);

        // Collection.parallelStream(); // returns a non-sequential stream
        Stream<Character> stream4 = cList.parallelStream();
        println.accept(stream4);

        // Stream.empty();
        Stream<Character> stream5 = Stream.empty(); // returns an empty stream
        println.accept(stream5);

        // Stream.of(T... values); // returns a sequential ordered stream whose elements are the specified values
        Stream<Character> stream6 = Stream.of('a', 'b', 'c', 'd');
        println.accept(stream6);

        // Stream.of(T t); // returns a singleton sequential stream
        Stream<Character> stream7 = Stream.of('a');
        println.accept(stream7);

        // Stream.ofNullable(T t); // returns an empty stream if null, otherwise a singleton sequential stream
        Stream<Character> stream8 = Stream.ofNullable('a');
        println.accept(stream8);

        // Stream.iterate(T seed, Predicate<? super T> hasNext, UnaryOperator<T> next);
        Stream<Character> stream9 = Stream.iterate(null, null, null);
        println.accept(stream9);

        // Stream.iterate(T seed, UnaryOperator<T> f);
        // infinite sequential ordered Stream, elements generated by UnaryOperator
        Stream<Character> stream10 = Stream.iterate(null, null);
        println.accept(stream10);

        // Stream.generate(Supplier<? extends T> s);
        // infinite sequential unordered stream, elements generated by Supplier
        Supplier<List<Character>> supplierList = () -> Arrays.asList('a', 'b', 'c', 'd');
        Stream<List<Character>> stream11 = Stream.generate(supplierList);
        println.accept(stream11);

        // Stream.concat(Stream<? extends T> a, Stream<? extends T> b); // it concats 2 streams into 1
        Stream<Character> stream12 = Stream.concat(stream3, stream4);
        println.accept(stream12);

    }

}

/*

-----------------------------------------------------------------------------------------------------------------------------------------------------------
> Stream Class
-----------------------------------------------------------------------------------------------------------------------------------------------------------
- NOTE: java.io.stream (processing binary data to/from files) != java.util.stream (processing objects inside collection)
- Collections like List, Set will be used if we want to represent a group of similar objects as a single entity,
  whereas Stream will be used to process a group of objects present inside a Collection.
- The java.util.stream API has classes for processing sequences of objects that are stored inside the Collections.
- The central API class is the Stream<T>.
- We can create a Stream from Collection, Arrays, Iterator, or by passing the elements directly to Stream.
- A Stream doesnâ€™t store its elements. They may be stored in an underlying Collection or generated on demand.
- The Stream operations do not mutate their source. Instead, they return new Stream that hold the result.
- In Stream, the code is written in a declarative way
  (we specify what we want to achieve like in query style as opposed to specifying how to implement an operation).
-----------------------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------------------------------------
> Create A Stream<T> Object Using Collection
-----------------------------------------------------------------------------------------------------------------------------------------------------------
1) Collection.stream();
   - returns a sequential stream

2) Collection.parallelStream();
   - returns a non-sequential stream
-----------------------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------------------------------------
> Create A Stream<T> Object Using Arrays
-----------------------------------------------------------------------------------------------------------------------------------------------------------
1) Arrays.stream(T[] array);
   - creates a stream from an array

2) Arrays.stream(T[] array, int startInclusive, int endExclusive);
   - creates a stream from a part of an array
-----------------------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------------------------------------
> Create A Stream<T> Object Using Stream
-----------------------------------------------------------------------------------------------------------------------------------------------------------
1) Stream.empty();
   - empty stream

2) Stream.of(T... values);
   - returns a sequential ordered stream whose elements are the specified values

3) Stream.of(T t);
   - returns a singleton sequential stream

4) Stream.ofNullable(T t);
   - returns an empty stream if null, otherwise a singleton sequential stream

5) Stream.iterate(T seed, UnaryOperator<T> f);
   - infinite sequential ordered Stream, elements generated by UnaryOperator

6) Stream.iterate(T seed, Predicate<? super T> hasNext, UnaryOperator<T> next);

7) Stream.generate(Supplier<? extends T> s);
   - infinite sequential unordered Stream, elements generated by Supplier

8) Stream.concat(Stream<? extends T> a, Stream<? extends T> b);
   - it concat 2 streams into 1
-----------------------------------------------------------------------------------------------------------------------------------------------------------

 */